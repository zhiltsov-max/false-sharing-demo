# Введение

В данном примере рассматривается проблема быстродействия приложения,
известная под названием “ложное разделение данных” (False Sharing).
Проблема заключается в том, что данные, которые не должны оказывать
влияние друг на друга, при некоторых условиях оказываются зависимыми
в силу внутреннего устройства процессора и организации его работы с
памятью. Как следствие, программа работает с меньшей производительностью,
чем изначально ожидалось.

# Описание проблемы

Проблема возникает в многопоточных приложениях, выполняемых параллельно,
при обработке данных, изменяющихся во время обработки.
Чтобы понять эту проблему необходимо обратиться к внутреннему устройству
процессора и рассмотреть принципы его работы с памятью.

Когда процессор обрабатывает некоторые данные, находящиеся в памяти,
ему необходимо читать и (или) записывать значения в памяти. Как известно,
обращение к внешней памяти — операция длительная, поэтому для ускорения
работы используется многоуровневая архитектура памяти. В каждым последующим
уровнем снижается скорость доступа к данным, но повышается объем
хранимой информации. Например, структура может быть такой (1 такт ~ 0.3 нс):
- Регистры процессора
- Кеши процессора
    - Кеш нулевого уровня (L0) (256 Б, задержка, задержка 1 такт)
    - Кеш первого уровня (L1) (64 КБ, задержка 2-4 такта)
    - Кеш второго уровня (L2) (1 МБ, задержка 10 тактов)
    - Кеш третьего уровня (L3) (6 МБ, задержка 40-80 тактов)
- Оперативная память (RAM) (16 ГБ, задержка 160 тактов (100 нс))
- Долговременная память (SSD, HDD, задержка 10 мс)

Чтобы оценить время доступа к памяти, рассмотрим следующую таблицу:
```
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy             3,000   ns        3 us
Send 1K bytes over 1 Gbps network       10,000   ns       10 us
Read 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms
```
![Визуализация](https://i.stack.imgur.com/a7jWu.png)

Можно видеть, что с каждым последующим уровнем памяти время доступа
увеличивается в разы. Многоуровневая система кешей позволяет сократить
время доступа к данным, если они расположены близко друг к другу и
требуют частого обращения.

Далее, рассмотрим архитектуры вычислительных систем относительно
многозадачности. Для организации параллельного исполнения команд
могут использоваться:
- многопроцессорные системы
- многоядерные системы
- векторные инструкции обработки данных
Проблему ложного разделения данных будем рассматривать на примере
многоядерных систем. В других случаях общие принципы сохраняются.

При параллельной обработке данных несколькими вычислительными
элементами (ядрами, процессорами, узлами и т.д.) данные для обработки
последовательно помещаются в кеши всех уровней. В этот момент появляется
проблема поддержания кешей в согласованном состоянии. Например,
в случае одного процессора с несколькими ядрами для этого разработаны
и используются различные протоколы согласования кешей. В случаях, когда
данные не изменяются в ходе вычислений, либо каждый обработчик работает
со своим фрагментом данных согласование кешей выполнять не требуется, т.к.
все обработчики "видят" актуальные данные. Однако, если несколько
обработчиков выполняют вычисления над одними данными и хотя бы один из них
изменяет общие (разделяемые) данные, возникает необходимость обновления
информации в кешах других обработчиков, чтобы они использовали актуальные
данные для вычислений.

В кешах процессора данные, как правило, хранятся строками определенного
размера, в современных процессорах он составляет 64 байта.
Если один из обработчиков изменил данные в строке своего кеша, строки
кешей других обработчиков, содержащие измененные данные, подлежат
синхронизации. Строки обновляются во всех кешах по пути от общей памяти
до обработчика. Например, для современных процессоров кеши уровней 0-2
являются локальными для каждого вычислительного ядра, в то время как кеш
3-го уровня является разделяемым. Соответственно, при изменении одним из
ядер значения в памяти, изменения распространятся до кеша третьего уровня,
а затем, при их использовании другими ядрами, будут загружены из него.

Если несколько обработчиков действительно работают с
общими данными (например, пользуются средствами синхронизации), то
такое поведение вполне корректно и уместно. В этом случае разделение
данных называется *истинным* (*true sharing*). Однако, если обновляются
несвязанные с точки зрения обработки данные, возникает необоснованное
замедление работы системы из-за синхронизации. В этом случае разделение
данных называется *ложным* (*false sharing*).

## Демонстрация проблемы

Пусть имеется несколько потоков (threads) обработка данных, работающих
независимо. В процессе вычислений используются данные, находящиеся:
- (А) в общей памяти достаточно близко друг к другу, чтобы оказаться в одной
- (Б) в общей памяти достаточно далеко друг от друга
строке кеша
В ходе вычислений потоки записывают данные в разделяемую память.

Код функции обработчика данных (C++):
``` c
void calc(int& var, const size_t iterations) {
  for (size_t i = 0; i < iterations; ++i) {
    var += i % 100;
  }
}
```
Используется простейшая функция для вычислений выполняющая суммирование
ряда натуральных чисел по модулю. Переменная `var` - ссылка (указатель)
на разделяемую область памяти. В каждой итерации цикла выполняется
чтение и изменение разделяемой области памяти.

Управляющий код (С++):
``` c
void test(const size_t iterations) {
  // Вариант A
  int value0 = 0;
  int value1 = 0;

  // Вариант Б
  alignas(64) int value0 = 0;
  alignas(64) int value1 = 0;

  // Создание потоков
  thread t1(calc, ref(value0), iterations);
  thread t2(calc, ref(value1), iterations);

  // Ожидание потоков
  t1.join();
  t2.join();
}
```
В разделяемой памяти размещаются переменные. Создаются потоки для
обработки, запускаются, ожидается их завершение.

Предполагаемый результат выполнения кода:
вариант А работает значительно дольше варианта Б.

[Исходный код примера](benchmark/main.cxx). Для сборки и запуска требуются:
- `CMake` версии 3.0 и выше ([официальный сайт](https://cmake.org/))
- Компилятор С++ с поддержкой стандарта С++11 (проверены GCC и MSVC) 
    ([список](https://en.cppreference.com/w/cpp/compiler_support))

## Результаты запусков

В таблице представлены результаты запусков демонстрационной программы.
Выполнялось по несколько запусков, выбиралось наилучшее время.

| Количество ядер | Число итераций | Вариант программы | Время выполнения (c) |
| :-------------: | :------------: | :---------------: | :------------------: |
| 1 (2 HT)        | 10e8           | A                 |  1.5                 |
|                 |                | Б                 |  0.6                 |
| 1 (2 HT)        | 10e9           | A                 |  12.2                |
|                 |                | Б                 |  6.5                 |
| 16 (32 HT)      | 10e8           | A                 |  2.3                 |
|                 |                | Б                 |  0.9                 |
| 16 (32 HT)      | 10e9           | A                 |  24.9                |
|                 |                | Б                 |  9.9                 |

Из полученных результатов можно видеть, что время работы при наличии
ложного разделения данных приблизительно вдвое превышает время работы
программы без рассматриваемой проблемы. Кроме того, можно видеть
интересный результат — при наличии лишь одного физического ядра
и двух логических программа работает быстрее, чем при наличии 16 физических
и 32 логических ядер. Предположительно, это может быть связано с более низкой
частотой ядер и с частым изменением ядра, на котором происходит обработка.

Для исключения негативного влияния на результаты экспериментов, оптимизация
кода была выключена (`-О0`). При наличии оптимизации код обработчика
может быть в значительной степени оптимизирован. Например:
- может быть удален цикл и заменен на вычисление по формуле
- может быть использована векторизация вычислений
- переменная может быть помещена в регистр (если компилятор докажет
    ее независимость)

Таким образом, можно считать, что гипотеза о негативном влиянии ложного
разделения данных на процесс вычислений в многопроцессной среде подтверждена.

## Обнаружение проблемы и подходы к решению

Для решения проблемы необходимо разместить независимые данные в памяти так,
чтобы они не находились в одной строке кеша. Этого можно добиться используя:
- выравнивание данных на определенные адреса при размещении в памяти
- предварительное выделение памяти и размещение несвязанных данных в ней
    на достаточном удалении друг от друга
- выравнивание объектов на размер строки кеша (например, в С++ для этого можно
    использовать оператор `alignas`, атрибуты или директивы компиляторов)

Обнаружение проблемы ложного разделения данных может быть весьма
нетривиальной задачей, так как ее проявление зависит от многих факторов.
Тем не менее, можно выделить несколько подходов к обнаружению и предотвращению
проблемы, и разделить их на две категории: пассивные и активные.

К пассивным методам можно отнести следование определенным правилам при работе
с разделяемыми объектами. например, таким правилом может быть обязательное
выравнивание объектов и размещение их в памяти с определенным шагом. В
демонстрационном примере использован этот подход. Однако, следует иметь
в виду, что такие действия хоть и могут защитить от исследуемой проблемы,
но в то же время могут принести и значительное увеличение требуемой памяти.

К активным методам можно отнести экспертную оценку кода и использование
специализированных средств профилирования кода. Применение экспертного метода
может быть эффективно, однако в значительной степени зависит от сложности и
объема кода, а также человеческого фактора. С другой стороны,
специализированные средства могут ошибаться, выводить недостаточно точную
информацию и быть недостаточно функциональными. Примерами полезных
инструментов профилирования кода являются:
- [perf](https://perf.wiki.kernel.org/index.php/Main_Page)
- [Intel (R) Performance Counter Monitor](https://software.intel.com/en-us/articles/intel-performance-counter-monitor)
- [Intel (R) VTune Amplifier (TM)](https://software.intel.com/en-us/vtune)
- [Predator](https://github.com/plasma-umass/Predator)
- [Shefiff](https://github.com/plasma-umass/sheriff)

Пример обнаружения ложного разделения данных в
[Intel (R) VTune Amplifier (TM)](https://software.intel.com/en-us/vtune-amplifier-cookbook-false-sharing).

# Заключение

В данном примере рассмотрена проблема ложного разделения данных в
многопоточной среде. Описана суть проблемы и ее причины. Приведен пример
кода на языке С++, в котором воспроизводится проблема. Проведены эксперименты,
подтверждающие наличие проблемы. Указаны способы обнаружения и борьбы.
